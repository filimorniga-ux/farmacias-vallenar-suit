'use server';

import { query } from '@/lib/db';
import { Terminal } from '@/domain/types';
import { revalidatePath } from 'next/cache';

/**
 * Registers a new terminal (or updates existing one based on ID).
 * If hardwareId is provided (e.g., from local storage or cookie), we can link it.
 */
/**
 * Creates a new terminal with robust validation.
 * Ensures location_id is present and defaults status to CLOSED.
 */
export async function createTerminal(data: { name: string; location_id: string; hardware_id?: string }) {
    try {
        if (!data.location_id) {
            return { success: false, error: 'Location ID is required' };
        }

        // Auto-generate ID if not provided (though usually IDs are UUIDs generated by DB or client)
        // Assuming ID is generated by DB default or we need to gen it.
        // Looking at schema insert: VALUES ($1, $2, $3...) it expects ID.
        // Let's generate one if not passed, or use nanoid/uuid if available.
        // Since we don't have uuid import visible, let's use crypto or time-random.
        // Actually, the original registerTerminal took `terminalId`.
        // Let's generate a robust ID.
        const id = data.hardware_id || `TERM-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

        await ensureTerminalColumns(); // Ensure schema is ready

        const res = await query(`
            INSERT INTO terminals (id, location_id, name, status, created_at, is_active)
            VALUES ($1, $2, $3, 'CLOSED', NOW(), true)
            RETURNING *
        `, [id, data.location_id, data.name]);

        // revalidatePath('/'); // Global refresh
        return { success: true, data: res.rows[0] };
    } catch (error) {
        console.error('Error creating terminal:', error);
        return { success: false, error: 'Database Error' };
    }
}

/**
 * Legacy wrapper or update specific
 */
export async function registerTerminal(terminalId: string, locationId: string, name: string) {
    return createTerminal({ name, location_id: locationId, hardware_id: terminalId });
}

/**
 * Opens a terminal for a shift.
 * Sets status to OPEN and assigns current cashier.
 */
export async function openTerminal(terminalId: string, userId: string, initialCash: number) {
    try {
        console.log(`ðŸ”Œ Opening terminal ${terminalId} for user ${userId} with $${initialCash}`);

        // 0. AUTO-CLEANUP: Close any existing sessions for this user (Prevent "User already has session" error)
        await query(`
            UPDATE cash_register_sessions
            SET closed_at = NOW(), 
                status = 'CLOSED_AUTO', 
                notes = 'Auto-closed by new login'
            WHERE user_id = $1 AND closed_at IS NULL
        `, [userId]);

        // 1. Validation Checks
        const termRes = await query('SELECT * FROM terminals WHERE id = $1', [terminalId]);
        if (termRes.rows.length === 0) return { success: false, error: 'Terminal not found' };

        const terminal = termRes.rows[0];
        if (terminal.status === 'OPEN') {
            // Check if it's actually the SAME user session (idempotency check could go here, but for now we error or auto-clean above)
            // If status is OPEN but we just closed the user's sessions, it might be occupied by SOMEONE ELSE.
            // But we already checked that in the frontend.
            return { success: false, error: 'Terminal is already open (Status: OPEN)' };
        }

        const userRes = await query('SELECT role, assigned_location_id FROM users WHERE id = $1', [userId]);
        if (userRes.rows.length === 0) return { success: false, error: 'User not found' };

        // 2. Register Cash Movement (Initial Fund)
        // We import dynamically to avoid circular deps if any (good practice kept)
        const { createCashMovement } = await import('./cash');
        try {
            await createCashMovement({
                shift_id: terminalId,
                user_id: userId,
                type: 'APERTURA',
                amount: initialCash,
                description: 'Apertura de Caja',
                timestamp: Date.now(),
                reason: 'INITIAL_FUND',
                is_cash: true,
                id: '' // Auto-gen
            } as any);
        } catch (cashError) {
            console.error('Failed to create initial cash movement:', cashError);
            // We continue? Or fail? Usually strict financial apps should fail.
            throw new Error('Could not register initial cash fund.');
        }

        // 3. Update Terminal Status (Physical Lock)
        await query(`
            UPDATE terminals 
            SET status = 'OPEN', current_cashier_id = $2
            WHERE id = $1
        `, [terminalId, userId]);

        // 4. Create Session (The Critical Step)
        // STRICT SCHEMA INSERT: id, terminal_id, user_id, opening_amount, status, opened_at.
        // We generate ID manually to ensure it works if DB doesn't auto-gen UUIDs.
        const newSessionId = `SESSION-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

        try {
            await query(`
                INSERT INTO cash_register_sessions (
                    id, 
                    terminal_id, 
                    user_id, 
                    opening_amount, 
                    status, 
                    opened_at
                ) VALUES ($1, $2, $3, $4, 'OPEN', NOW())
            `, [newSessionId, terminalId, userId, initialCash]);
        } catch (insertError: any) {
            console.error('âŒ CRITICAL: Session Insert Failed:', insertError);
            // Attempt rollback of terminal status
            await query("UPDATE terminals SET status = 'CLOSED', current_cashier_id = NULL WHERE id = $1", [terminalId]);
            throw new Error(insertError.message || 'Database refused session creation');
        }

        // revalidatePath('/');
        return {
            success: true,
            data: {
                id: newSessionId,
                terminal_id: terminalId,
                user_id: userId,
                start_time: Date.now(),
                opening_amount: initialCash,
                status: 'ACTIVE'
            }
        };

    } catch (error: any) {
        console.error('Error in openTerminal flow:', error);
        return { success: false, error: error.message || 'Unknown error opening terminal' };
    }
}

/**
 * Closes a terminal.
 */
export async function closeTerminal(terminalId: string, userId: string, finalCash: number, comments: string, withdrawalAmount?: number) {
    try {
        const { createCashMovement } = await import('./cash');

        // Register Closing Movement
        const movementResult = await createCashMovement({
            shift_id: terminalId,
            user_id: userId,
            type: 'CIERRE',
            amount: finalCash, // This is what is counted
            description: `Cierre de Caja: ${comments}`,
            timestamp: Date.now(),
            reason: 'OTHER', // Closing logic
            is_cash: true,
            id: ''
        } as any);

        if (!movementResult.success) {
            throw new Error('Failed to register closing cash');
        }

        // Close Terminal in DB
        await query(`
            UPDATE terminals 
            SET status = 'CLOSED', current_cashier_id = NULL
            WHERE id = $1
        `, [terminalId]);

        // Auto Treasury Entry (Custody Chain V2)
        const { createRemittance } = await import('./treasury');

        const termRes = await query("SELECT location_id, name FROM terminals WHERE id = $1", [terminalId]);
        const locationId = termRes.rows[0].location_id;

        if (withdrawalAmount && withdrawalAmount > 0) {
            await createRemittance(
                locationId,
                terminalId,
                withdrawalAmount,
                userId
            );
        }

        // revalidatePath('/');
        return { success: true };
    } catch (error) {
        console.error('Error closing terminal:', error);
        return { success: false, error: 'Failed to close terminal' };
    }
}

export async function getTerminalStatus(terminalId: string) {
    try {
        const res = await query('SELECT * FROM terminals WHERE id = $1', [terminalId]);
        if (res.rows.length === 0) return null;
        return {
            id: res.rows[0].id,
            name: res.rows[0].name,
            status: res.rows[0].status,
            current_cashier_id: res.rows[0].current_cashier_id
        };
    } catch (error) {
        return null;
    }
}

export async function getTerminalsByLocation(locationId: string): Promise<{ success: boolean; data?: Terminal[]; error?: string }> {
    try {
        // Detailed Telemetry Query
        const result = await query(`
            SELECT 
                t.id, 
                t.name, 
                t.location_id, 
                t.status, 
                t.current_cashier_id,
                t.allowed_users,
                u.name as cashier_name,
                s.opened_at,
                s.id as session_id,
                s.opening_amount,
                s.user_id as session_user_id,
                s.blind_counts
            FROM terminals t
            LEFT JOIN users u ON t.current_cashier_id = u.id
            LEFT JOIN cash_register_sessions s ON (s.terminal_id = t.id AND s.status = 'OPEN')
            WHERE t.location_id = $1 
              AND (t.deleted_at IS NULL)
            ORDER BY t.name ASC
        `, [locationId]);

        if (result.rows.length === 0) {
            return { success: true, data: [] };
        }

        const terminals: Terminal[] = result.rows.map((row: any) => ({
            id: row.id,
            name: row.name,
            location_id: row.location_id,
            status: row.status === 'OPEN' ? 'OPEN' : 'CLOSED',
            current_cashier_id: row.current_cashier_id,
            current_cashier_name: row.cashier_name,
            opened_at: row.opened_at ? new Date(row.opened_at).getTime() : undefined,
            blind_counts_count: row.blind_counts || 0,
            session_id: row.session_id,
            session_opening_amount: row.opening_amount ? Number(row.opening_amount) : undefined,
            session_start_time: row.opened_at ? new Date(row.opened_at).getTime() : undefined,
            authorized_by_name: undefined,
            allowed_users: row.allowed_users || [] // Add this
        }));

        return { success: true, data: terminals };
    } catch (error: any) {
        console.error('Error fetching terminals with telemetry:', error);
        return { success: false, error: 'Failed to fetch terminals' };
    }
}

/**
 * Ensures that the terminals table has the necessary columns.
 * Specifically 'is_active' and 'deleted_at' for soft deletes.
 */
async function ensureTerminalColumns() {
    try {
        await query(`ALTER TABLE terminals ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT TRUE;`);
        await query(`ALTER TABLE terminals ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP;`);
    } catch (e) {
        // Ignore if already exists or race condition
    }
}

/**
 * Updates a terminal's configuration.
 */
export async function updateTerminal(id: string, data: { name: string; is_active?: boolean }) {
    try {
        await ensureTerminalColumns();
        await query(`
            UPDATE terminals 
            SET name = $2, is_active = COALESCE($3, is_active)
            WHERE id = $1
        `, [id, data.name, data.is_active]);

        // revalidatePath('/settings/organization');
        // revalidatePath('/settings/config/organization');
        // revalidatePath('/');
        return { success: true };
    } catch (error) {
        console.error('Error updating terminal:', error);
        return { success: false, error: 'Failed to update terminal' };
    }
}

/**
 * Soft deletes a terminal.
 * Validates that no active session exists.
 */
export async function deleteTerminal(id: string) {
    try {
        await ensureTerminalColumns();
        // 1. Check for active sessions
        const sessionRes = await query(`
            SELECT id FROM cash_register_sessions 
            WHERE terminal_id = $1 AND closed_at IS NULL
        `, [id]);

        if (sessionRes.rows.length > 0) {
            return { success: false, error: 'No se puede eliminar: Tiene un turno abierto.' };
        }

        // 2. Soft Delete
        await query(`
            UPDATE terminals 
            SET deleted_at = NOW(), is_active = false, status = 'DELETED'
            WHERE id = $1
        `, [id]);

        // revalidatePath('/settings/organization');
        // revalidatePath('/settings/config/organization');
        // revalidatePath('/');
        return { success: true };
    } catch (error) {
        console.error('Error deleting terminal:', error);
        return { success: false, error: 'Failed to delete terminal' };
    }
}

/**
 * Get TERMINALS available for OPENING a shift.
 * Excludes: Deleted, Inactive, and Already Opened terminals.
 */
export async function getAvailableTerminalsForShift(locationId: string) {
    try {
        await ensureTerminalColumns();
        const result = await query(`
            SELECT * FROM terminals 
            WHERE location_id = $1::uuid 
              AND (is_active = TRUE OR is_active IS NULL)
              AND (deleted_at IS NULL)
              AND status != 'DELETED'
              AND id NOT IN (
                  SELECT terminal_id FROM cash_register_sessions WHERE closed_at IS NULL
              )
            ORDER BY name ASC
        `, [locationId]);

        return { success: true, data: result.rows };
    } catch (error: any) {
        console.error('Error fetching available terminals:', error);
        // Fallback for missing columns if migration failed (though it shouldn't)
        if (error.code === '42703') { // Undefined column
            return { success: false, error: 'Database schema mismatch. Please refresh.' };
        }
        return { success: false, error: 'Failed to fetch available terminals' };
    }
}
/**
 * Forces a terminal shift to close.
 * Used for administrative overrides when a terminal is stuck/zombie.
 */
export async function forceCloseTerminalShift(terminalId: string, userId: string) {
    try {
        // 1. Find the open session
        const sessionRes = await query(`
            SELECT id 
            FROM cash_register_sessions 
            WHERE terminal_id = $1 AND closed_at IS NULL
        `, [terminalId]);

        if (sessionRes.rows.length > 0) {
            const sessionId = sessionRes.rows[0].id;

            // 2. Close the Session
            await query(`
                UPDATE cash_register_sessions
                SET closed_at = NOW(), 
                    status = 'CLOSED_FORCE', 
                    notes = $2
                WHERE id = $1
            `, [sessionId, `Cierre Forzado por Admin ${userId}`]);
        }

        // 3. Reset Terminal Status (Atomic Reset)
        await query(`
            UPDATE terminals 
            SET status = 'CLOSED', 
                current_cashier_id = NULL
            WHERE id = $1
        `, [terminalId]);

        // revalidatePath('/');
        return { success: true };
    } catch (error) {
        console.error('Error forcing terminal close:', error);
        return { success: false, error: 'Failed to force close terminal' };
    }
}
